---
title: "Discovering a Global Data Model from Event Logs - Complementary Notebook"
output:
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
library(here)
library(ggplot2)
library(dplyr)
library(tidyverse)
library(igraph)
library(textshape)
```


```{r functions, echo=FALSE}
a2a <- function(df, relative = FALSE) {
  if(relative == FALSE){
    df %>% 
      group_by(Activity) %>%
      summarise(across(everything(), ~ sum(!is.na(.x))))
  } else {
    df %>%
      group_by(Activity) %>%
      summarise(across(everything(), ~ sum(!is.na(.x)) / n()))
  }
}

dropSuperfluousAttributes <- function(df, dropCols = NULL) {
  if(is.null(dropCols)) {
    dropCols <- c("Case.ID", "Resource", "Timestamp", "Variant", "Lifecycle")
  }
  df %>% select(-contains(dropCols))
}

replaceEmptyWithNA <- function(df, keepZeroes = FALSE) {
  df[df == ""] <- NA
  if(keepZeroes == FALSE) df[df == "0"] <- NA
  df
}

MLAD.Deep.setup <- function(a2a) {
  df <- slice(a2a, 0)
  df <- bind_rows(df, a2a %>% select(Activity))
  df[is.na(df)] <- 0
  df
}

MLAD.Deep.fill <- function(scaffold, a2a) {
  columns <- colnames(a2a)
  rows <- rownames(a2a)
  for(c in columns) {
    for(r in rows) {
      scaffold[r, c] <- a2a[r, c]
    }
  }
  scaffold
}

MLAD <- function(a, b) {
  sort(intersect(colnames(a), colnames(b)))
}
```

## Loading of Datasets

For reproducibility, this section shows the datasets' preprocessing.
 
### Offer Applications (BPI 2017)

Meta-attributes are removed, empty strings are coerced to NA. Note, that this dataset makes a distinction between 0 and empty strings, so zeroes are not coerced to NA as they are a value.

```{r dataLoading Offers}

OfferApplications <- read.csv(here("data", "bpi17.csv"))
OfferApplications <- dropSuperfluousAttributes(OfferApplications, c("Resource", "Timestamp", "Variant", "Lifecycle", "Event", "Action"))
OfferApplications <- replaceEmptyWithNA(OfferApplications, keepZeroes = TRUE)
Offers <- read.csv(here("data", "bpi17_offer_log.csv"))
Offers <- dropSuperfluousAttributes(Offers, c("Resource", "Timestamp", "Variant", "Lifecycle", "Event", "Action"))
Offers <- replaceEmptyWithNA(Offers, keepZeroes = TRUE)
```

### Permits (BPI 2020)

Meta-attributes are removed, empty strings and zeroes are coerced to NA.

```{r dataLoading Permits}
Permits <- read.csv(here("data", "PermitLog.csv"))
Permits <- replaceEmptyWithNA(Permits)
Permits <- dropSuperfluousAttributes(Permits)

InternationalDeclarations <- read.csv(here("data", "InternationalDeclarations.csv"))
InternationalDeclarations <- replaceEmptyWithNA(InternationalDeclarations)
InternationalDeclarations <- dropSuperfluousAttributes(InternationalDeclarations)

DomesticDeclarations <- read.csv(here("data", "DomesticDeclarations.csv"))
DomesticDeclarations <- replaceEmptyWithNA(DomesticDeclarations)
DomesticDeclarations <- dropSuperfluousAttributes(DomesticDeclarations)

RequestForPayment <- read.csv(here("data", "RequestForPayment.csv"))
RequestForPayment <- replaceEmptyWithNA(RequestForPayment)
RequestForPayment <- dropSuperfluousAttributes(RequestForPayment)

PrepaidTravelCost <- read.csv(here("data", "PrepaidTravelCost.csv"))
PrepaidTravelCost <- replaceEmptyWithNA(PrepaidTravelCost)
PrepaidTravelCost <- dropSuperfluousAttributes(PrepaidTravelCost)

```


```{r dataLoading Mock, echo = FALSE}
#eventlogmockP1 <- read.csv("D:/uni/bpm/eventlogmockP1.csv")
#eventlogmockP1[eventlogmockP1 == ""] <- NA
#eventlogmockP2 <- read.csv("D:/uni/bpm/eventlogmockP2.csv")
#eventlogmockP2[eventlogmockP2 == ""] <- NA
```


```{r dataLoading Traffic, include = FALSE}
RoadTraffic <- read.csv(here("data", "Road_Traffic_Fine_Management_Process.csv"))
RoadTraffic <- replaceEmptyWithNA(RoadTraffic)
RoadTraffic <- dropSuperfluousAttributes(RoadTraffic)
```

## Dataset Transformations as Discussed in Main Paper

### Offer Applications (BPI 2017)

Event Logs are translated to A2A Matrices. MLAD Matrices are combined by union.

```{r bpi2017}
OfferApplications.a2a <- a2a(OfferApplications)
OfferApplications.a2a.relative <- a2a(OfferApplications, relative = TRUE)
Offers.a2a <- a2a(Offers)
#Offers.a2a.relative <- a2a(Offers, relative = TRUE)

print("Class attributes found by MLAD:")
MLAD(Offers, OfferApplications)

Offer.union <- bind_rows(OfferApplications, Offers)
Offer.union.a2a <- a2a(Offer.union)

Offer.union.a2a.remaining <- Offer.union.a2a[ , !(colnames(Offer.union.a2a) %in% MLAD(Offers, OfferApplications))]
print("Remaining attributes found by FCSE:")
colnames(Offer.union.a2a.remaining)
#Offer.union.a2a.relative <- a2a(Offer.union, relative = TRUE)
```
### Permits (BPI 2020)

Event logs are translated to A2A Matrices.

```{r bpi2020}
Permits.a2a <- a2a(Permits, relative = TRUE)
DomesticDeclarations.a2a <- a2a(DomesticDeclarations, relative = TRUE)
InternationalDeclarations.a2a <- a2a(InternationalDeclarations, relative = TRUE)
PrepaidTravelCost.a2a <- a2a(PrepaidTravelCost, relative = TRUE)
RequestForPayment.a2a <- a2a(RequestForPayment, relative = TRUE)

permits.union <- bind_rows(DomesticDeclarations, InternationalDeclarations, Permits, PrepaidTravelCost, RequestForPayment)
permits.union.a2a <- a2a(permits.union)

permits.union.a2a.rel <- a2a(Permits, relative = TRUE)
Permits.a2a <- a2a(Permits)
PrepaidTravelCost.a2a <- a2a(PrepaidTravelCost)
RequestForPayment.a2a <- a2a(RequestForPayment)
DomesticDeclarations.a2a <- a2a(DomesticDeclarations)
InternationalDeclarations.a2a <- a2a(InternationalDeclarations)


reducedPermits <- Permits %>% select(Activity, BudgetNumber, Overspent, OverspentAmount, ProjectNumber, RequestedBudget, TotalDeclared, id)
reducedDomesticDeclarations <- DomesticDeclarations %>% select(Activity, Amount, BudgetNumber, id)
reducedInternationalDeclarations <- InternationalDeclarations %>% select(Activity, Amount, BudgetNumber, id)
reducedRequestForPayment <- RequestForPayment %>% select(Activity, Project, RequestedAmount, Rfp_id)
reducedPrepaidTravelCost <- PrepaidTravelCost %>% select(Activity, Project, RequestedAmount, Rfp_id)

reducedUnion <- bind_rows(reducedPermits, reducedDomesticDeclarations, reducedInternationalDeclarations, reducedRequestForPayment, reducedPrepaidTravelCost)
reducedUnion.a2a <- a2a(reducedUnion)
reducedPermits.a2a <- a2a(reducedPermits)
reducedPermits.a2a.rel <- a2a(reducedPermits, relative = TRUE)
reducedDomesticDeclarations.a2a <- a2a(reducedDomesticDeclarations)
reducedInternationalDeclarations.a2a <- a2a(reducedInternationalDeclarations)
reducedRequestForPayment.a2a <- a2a(reducedRequestForPayment)
reducedPrepaidTravelCost.a2a <- a2a(reducedPrepaidTravelCost)
```


### Multi-log Access Detection for the bpi 2020
```{r bpi2020 mlad}
sort(intersect(colnames(Permits), colnames(InternationalDeclarations)))
sort(intersect(colnames(Permits), colnames(DomesticDeclarations)))
sort(intersect(colnames(Permits), colnames(RequestForPayment)))
sort(intersect(colnames(Permits), colnames(PrepaidTravelCost)))

sort(intersect(colnames(InternationalDeclarations), colnames(DomesticDeclarations)))
sort(intersect(colnames(InternationalDeclarations), colnames(RequestForPayment)))
sort(intersect(colnames(InternationalDeclarations), colnames(PrepaidTravelCost)))

sort(intersect(colnames(DomesticDeclarations), colnames(RequestForPayment)))
sort(intersect(colnames(DomesticDeclarations), colnames(PrepaidTravelCost)))

sort(intersect(colnames(RequestForPayment), colnames(PrepaidTravelCost)))

intersect(intersect(colnames(RequestForPayment), colnames(PrepaidTravelCost)), colnames(DomesticDeclarations))


DomInt.union <- bind_rows(DomesticDeclarations, InternationalDeclarations)
DomInt.union.a2a <- a2a(DomInt.union)

PrepaidRfp.union <- bind_rows(PrepaidTravelCost, RequestForPayment)
PrepaidRfp.union.a2a <- a2a(PrepaidRfp.union)
```

### Multi-log Access Detection in the Reduced BPI 2020 dataset. 
Reductions based on "Multi-perspective Analysis of Approval Processes based on Multiple Event Logs", by Bano et. al.
```{r reduced bpi2020 mlad}
sort(intersect(colnames(reducedPermits), colnames(reducedInternationalDeclarations)))
sort(intersect(colnames(reducedPermits), colnames(reducedDomesticDeclarations)))
sort(intersect(colnames(reducedPermits), colnames(reducedRequestForPayment)))
sort(intersect(colnames(reducedPermits), colnames(reducedPrepaidTravelCost)))

sort(intersect(colnames(reducedInternationalDeclarations), colnames(reducedDomesticDeclarations)))
sort(intersect(colnames(reducedInternationalDeclarations), colnames(reducedRequestForPayment)))
sort(intersect(colnames(reducedInternationalDeclarations), colnames(reducedPrepaidTravelCost)))

sort(intersect(colnames(reducedDomesticDeclarations), colnames(reducedRequestForPayment)))
sort(intersect(colnames(reducedDomesticDeclarations), colnames(reducedPrepaidTravelCost)))

sort(intersect(colnames(reducedRequestForPayment), colnames(reducedPrepaidTravelCost)))
reducedRfpPre.union <- bind_rows(reducedRequestForPayment, reducedPrepaidTravelCost)
reducedRfpPre.union.a2a <- a2a(reducedRfpPre.union)

reducedIntDom.union <- bind_rows(reducedInternationalDeclarations, reducedDomesticDeclarations)
reducedIntDom.union.a2a <- a2a(reducedIntDom.union)
```

```{r, echo= FALSE, eval=FALSE }
names.1 <- colnames(EL.1)
names.2 <- colnames(EL.2)


cat("Columns only in log.1:", names.1[!names.1 %in% names.2], "\n",
    "Columns only in log.2:", names.2[!names.2 %in% names.1])
```

```{r Approach 0, echo= FALSE, eval=FALSE}
#Rule 1 not applicable

#Rule 3
EL.offerless <- EL.1[!EL.1$Activity == "O_Create Offer", ]
# only "O_Create Offer" has any values in FirstWithdrawalAmount, NumberOfTerms, Accepted, MonthlyCost, Selected, CreditScore, OfferedAmount

EL.NAfree <- EL.offerless[!is.na(EL.offerless$CreditScore), ] #empty

# EL COMPLEMENT E_A1 => E_A2 = NA 
# => E_A1 UNION E_A2 = E_A1
# => "O_Create Offer" is an isolated Activity with non-isolated attributes (FirstWithdrawalAmount, NumberOfTerms, Accepted, MonthlyCost, Selected, CreditScore, OfferedAmount), with ONE class.


#-------------------------------------------
#Rule 2
EL.OfferID.exists <- EL.1[!is.na(EL.1$OfferID), ]
#head(EL.OfferID.exists)
activities.offerID.access <- unique(EL.OfferID.exists$Activity)
#cat(c("Rule 2 fulfilled by: ", activities.offerID.access, "\n")) #Activities accessing Attr "OfferID"


#Rule 4
EL.Remaining <- EL.offerless[! EL.offerless$Activity %in% activities.offerID.access, ]
#cat(c("OfferID empty?", sum(is.na(EL.Remaining$OfferID)) == nrow(EL.Remaining), "\n"))
#cat(c("OfferedAmount empty?", sum(is.na(EL.Remaining$OfferedAmount)) == nrow(EL.Remaining)))
# => Everything remaining accesses everything



#===>
#3. FirstWithdrawalAmount, NumberOfTerms, Accepted, MonthlyCost, Selected, CreditScore, OfferedAmount
#2. OfferID accessed by O_Created, O_Sent, O_Returned O_Accepted O_Refused O_Cancelled O_Sent
#4. Everything else


cat(c("Rule 1: ", "not applicable", "\n"))
cat(c("Rule 2: ", unique(EL.OfferID.exists$Activity), "\n"))
cat(c("Rule 3: ", "FirstWithdrawalAmount, NumberOfTerms, Accepted, MonthlyCost, Selected, CreditScore, OfferedAmount", "\n"))
cat(c("Rule 4: ", "Variant, Variant.index, lifecycle.transition, EventOrigin, Action, LoanGoal, ApplicationType, RequestedAmount", "\n"))
```


### Automated A2A Diagram Generation

Not part of the research questions, but interesting to see how the graphing algorithm clusters attributes.

```{r Graphing bipartite}

inc <- reducedUnion.a2a #put any a2a matrix here to generate a2a diagram
inc <- column_to_rownames(inc, 1)
g <- graph_from_incidence_matrix(inc, multiple = FALSE)

l <- layout.bipartite(g, vgap = 0.1)
plot(g, layout=-l[,2:1],
     vertex.label.cex=0.75, 
     vertex.label.family="Helvetica",
     vertex.label.font=1,
     
     vertex.shape="circle", 
     vertex.size=1, 
     vertex.label.color="black",
     edge.width=1,
     asp = 0.5,
     margin = 0)
```

This version doesn't plot the graph as bipartite graph (i.e., the structure of an A2A diagram is unenforced).

```{r Graphing naive}
plot(g,
     vertex.label.cex=0.75, 
     vertex.label.family="Helvetica",
     vertex.label.font=1,
     
     vertex.shape="circle", 
     vertex.size=1, 
     vertex.label.color="black",
     edge.width=1,
     asp = 0.5,
     margin = 0)

```


```{r RoadTraffictemp, include = FALSE}
RoadTraffic.a2a <- a2a(RoadTraffic)
RoadTraffic.a2a.relative <- a2a(RoadTraffic, relative = TRUE)
#write.csv(RoadTraffic.a2a, "roadTrafficA2A.csv")
```
